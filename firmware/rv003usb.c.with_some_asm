// Could be defined here, or in the processor defines.
#define SYSTEM_CORE_CLOCK 48000000
#define SYSTICK_USE_HCLK

#include "ch32v003fun.h"
#include <stdio.h>

#define USB_START_BIT 3
#define USB_SYNC_BIT 4
#define USB_PORT GPIOD
// Port D.3 = D+
// Port D.4 = D-
// Port D.5 = DPU

uint32_t wait_time = 0;

uint8_t bit_times[1280];

static inline void HandleBitTime( uint32_t bit_time )
{
	GPIOC->BSHR = 1;
	GPIOC->BSHR = (1<<16);
	if( bit_time < sizeof( bit_times ) )
		bit_times[bit_time]++;
}

void EXTI7_0_IRQHandler( void ) __attribute__((interrupt)) __attribute__((section(".srodata" )));
void EXTI7_0_IRQHandler( void ) 
{
	// Flash just a little blip.

	volatile uint32_t * gpio_in_reg = &GPIOD->INDR;

	if( ( *gpio_in_reg & (3<<USB_START_BIT) ) == 0 )
	{
		//EOP. TODO: Use this to help us tune the
		// oscillator frequency with HSITRIM.
		// Acknowledge the interrupt
		EXTI->INTFR = 1<<4;
		return;		
	}
	asm volatile( "" : : : "memory" );

	uint32_t now = SysTick->CNT;
	uint32_t last_time = now;

	#define BIT_TIMEOUT 180
	uint32_t timeout;

	// We don't know how long the main program took
	// on the instruction, so, we synchronize here.
	for( timeout = BIT_TIMEOUT; timeout; timeout-- )
		if( *gpio_in_reg & (1<<USB_SYNC_BIT) ) break;

	for( timeout = BIT_TIMEOUT; timeout; timeout-- )
		if( !( *gpio_in_reg & (1<<USB_SYNC_BIT) ) ) break;

	now = SysTick->CNT;
	wait_time = now - last_time; // Will be debugged in main.
	uint32_t bit_time;

	// Main bit loop.
	do
	{
		// TODO: can we use the timer interupt flags to 
		// detect a transition.

		// Detect an "L->H" transition
/*		asm volatile( "\
			.option   rvc;\n\
			c.li %[timeout], 1\n\
			1:\n\
				c.lw s0, 0(%[gpio_in_reg])\n\
				c.andi s0, (1<<4)\n\
				c.beqz s0, 2f\n\
				c.addi %[timeout], -16\n\
				c.bnez %[timeout], 1b\n\
			2:" : [timeout]"+r"(timeout) : [gpio_in_reg]"r"(gpio_in_reg) : "s0" );
*/
		for( timeout = BIT_TIMEOUT; timeout; timeout-- )
			if( *gpio_in_reg & (1<<USB_SYNC_BIT) ) break;
		now = SysTick->CNT;
		bit_time = now - last_time;
		HandleBitTime( bit_time );

		// Detect an "H->L" transition
/*		asm volatile( "\
			.option   rvc;\n\
			c.li %[timeout], 1\n\
			1:\n\
				c.lw s0, 0(%[gpio_in_reg])\n\
				c.andi s0, (1<<4)\n\
				c.bnez s0, 2f\n\
				c.addi %[timeout], -16\n\
				c.bnez %[timeout], 1b\n\
			2:" : [timeout]"+r"(timeout) : [gpio_in_reg]"r"(gpio_in_reg) : "s0" );
*/
		for( timeout = BIT_TIMEOUT; timeout; timeout-- )
			if( !(*gpio_in_reg & (1<<USB_SYNC_BIT)) ) break;

		// EOP.
		if( !(*gpio_in_reg) & (1<<USB_START_BIT)) break;
		now = SysTick->CNT;
		bit_time = now - last_time;
		HandleBitTime( bit_time );
	} while( !timeout );

	EXTI->INTFR = 1<<4;
}

int main()
{
	SystemInit48HSI();
	SetupDebugPrintf();

	SETUP_SYSTICK_HCLK

	// Enable GPIOs
	RCC->APB2PCENR |= RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO;

	// GPIO C0 Push-Pull
	GPIOC->CFGLR &= ~(0xf<<(4*0));
	GPIOC->CFGLR |= (GPIO_Speed_10MHz | GPIO_CNF_OUT_PP)<<(4*0);


	// GPIO D3 for input pin change.
	GPIOD->CFGLR =
		(GPIO_CNF_IN_PUPD)<<(4*1) |  // Keep SWIO enabled.
		(GPIO_SPEED_IN | GPIO_CNF_IN_PUPD)<<(4*3) |  //PD3 = GPIOD IN
		(GPIO_SPEED_IN | GPIO_CNF_IN_PUPD)<<(4*4) |  //PD4 = GPIOD IN
		(GPIO_Speed_10MHz | GPIO_CNF_OUT_PP)<<(4*5);

	// Configure the IO as an interrupt.
	AFIO->EXTICR = 3<<(4*2); //PORTD.3 (3 out front says PORTD, 3 in back says 3)
	EXTI->INTENR = 1<<4; // Enable EXT3
	EXTI->FTENR = 1<<4;  // Rising edge trigger

	// This drive GPIO5 high, which will tell the host that we are going on-bus.
	GPIOD->BSHR = 1<<5;

	// enable interrupt
	NVIC_EnableIRQ( EXTI7_0_IRQn );

	while(1)
	{
		GPIOC->BSHR = 1;   // Set pin high
		Delay_Ms( 1000 );
		GPIOC->BSHR = (1<<16); // Set the pin low
		Delay_Ms( 1000 );
		int i;

		NVIC_DisableIRQ( EXTI7_0_IRQn );

		for( i = 0; i < sizeof(bit_times); i++ )
		{
			printf( "%lu\t", bit_times[i] );
		}
		printf( "\n" );
		memset( bit_times, 0, sizeof( bit_times ) );

		NVIC_EnableIRQ( EXTI7_0_IRQn );
	}
}
